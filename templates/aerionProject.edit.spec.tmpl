import {async, ComponentFixture, fakeAsync, inject, TestBed, tick} from '@angular/core/testing';
import {FormBuilder, FormControl, FormGroup, FormsModule, ReactiveFormsModule, Validators} from '@angular/forms';
import {BrowserModule} from '@angular/platform-browser';
import {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, OnDestroy} from '@angular/core';
import {${upperName}Service} from '../project-service';
import {ActivatedRoute, Router} from '@angular/router';
import {empty, Observable, of, Subscription} from 'rxjs';
import {BaseComponent} from '../../base.component';
import {${upperName}EditComponent} from './project-edit.component';
import {${upperName}} from '../models/projects';
import {FormSubmission} from '../../../interfaces/formSubmission';
import any = jasmine.any;

class Mock${upperName}Service {
  project = new ${upperName}();
  validationErrors$: Observable<{}[]> = of(['404', 'server error'] );
  slected${upperName}$: Observable<${upperName}> = of(this.project);

  create() {}

  get() {}

  update() {}
}

class MockActivatedRoute {
  params: Observable<any> = of({'id': 1});
}

class MockRouter {
}

class MockFormBuilder {
  group() {}
}

class MockFormGroup {}

class MockBaseComponent implements OnDestroy {

  form: FormGroup;

  ngOnDestroy(): void {
    this.unsubscribeSubscription();
  }

  unsubscribeSubscription() {
  }
}


describe('${upperName}Component', () => {
  let component: ${upperName}Component;
  let fixture: ComponentFixture<${upperName}Component>;
  let route: ActivatedRoute;
  let projectService: ${upperName}Service;
  let formBuilder: FormBuilder;

  beforeEach(async(() => {
    TestBed.configureTestingModule({

      declarations: [${upperName}Component],
      providers: [
        {provide: ${upperName}Service, useClass: Mock${upperName}Service},
        {provide: ActivatedRoute, useClass: MockActivatedRoute},
        {provide: Router, useClass: MockRouter},
        {provide: BaseComponent, useClass: MockBaseComponent},
        {provide: FormBuilder, useClass: MockFormBuilder},
        {provide: FormGroup, useClass: MockFormGroup}
      ],
      imports: [
        FormsModule,
        BrowserModule,
        ReactiveFormsModule
      ],
      schemas: [CUSTOM_ELEMENTS_SCHEMA,
        NO_ERRORS_SCHEMA]
    }).compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(${upperName}Component);
    component = fixture.componentInstance;
    route = fixture.debugElement.injector.get(ActivatedRoute);
    formBuilder = fixture.debugElement.injector.get(FormBuilder);
    projectService = fixture.debugElement.injector.get(${upperName}Service);
  });

  it('should create', () => {

    // verify
    expect(component).toBeDefined();
  });

  describe('ngOnInit()', () => {
    it('should get the id from params and build form for selected project', () => {

      // setup
      formBuilder = new FormBuilder();
      const model = new ${upperName}();
      model.formErrors = {name: 'error', description: 'server error'};
      component.model = model;
      component.form = formBuilder.group(model.formControls);
      spyOn(projectService, 'get').and.returnValue('ss');
      spyOn(component, 'buildForm');
      spyOn(component.form, 'patchValue');
      projectService.selected${upperName}$ = of(new ${upperName}());



      // act
      component.ngOnInit();

      // verify
      component.routeSubscription = route.params.subscribe(params => {
        expect(projectService.get).toHaveBeenCalled();
      });
      expect(component.routeSubscription).toBeDefined();
      projectService.selected${upperName}$.subscribe(res => {
        expect(component.model).toBeDefined();
       expect(component.buildForm).toHaveBeenCalled();
       expect(component.form.patchValue).toHaveBeenCalled();
      });

      projectService.validationErrors$.subscribe(res => {
        expect(component.model.formErrors[1]).toEqual('server error');
      });
     });
  });

  describe('buildForm()', () => {
    it('should build the form', () => {

      // setup
      formBuilder  = new FormBuilder();
      const model = new ${upperName}();
      component.model = model;
      component.form = formBuilder.group(model.formControls);
      spyOn(component.formBuilder, 'group').and.returnValue(component.form);
      spyOn(component, 'onValueChanged');
      spyOn(component.form, 'valueChanges').and.returnValue(of(model));

      // act
       component.buildForm();

       // verify
      expect(component.formSubscription).toBeDefined();
      expect(component.onValueChanged).toHaveBeenCalled();
      expect(component.form).toBeDefined();
    });
  });

  describe('onSubmit()', () => {
    it('submitting the form', () => {
      // setup
      const model = new ${upperName}();
      component.model = model;
      spyOn(component.model, 'patchByForm').and.returnValue('');
      spyOn(projectService, 'update').and.returnValue('');
      const fs: FormSubmission<${upperName}> = {value: model, valid: true};

      // act
      component.onSubmit(fs);

      // verify
      expect(component.model.patchByForm).toHaveBeenCalled();
      expect(projectService.update).toHaveBeenCalled();
    });
  });

  describe('onSubmit()', () => {
    it('submitting the form', () => {
      // setup
      const model = new ${upperName}();
      component.model = model;
      spyOn(component, 'setFormTouchedAndDirtyIfNeeded').and.returnValue('');
      const fs: FormSubmission<${upperName}> = {value: model, valid: false};

      // act
      component.onSubmit(fs);

      // verify
      expect(component.setFormTouchedAndDirtyIfNeeded).toHaveBeenCalled();

    });
  });
});
